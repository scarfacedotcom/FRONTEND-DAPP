{"ast":null,"code":"import { ChaCha20Poly1305 as Y } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as Be } from \"@stablelib/hkdf\";\nimport { randomBytes as W } from \"@stablelib/random\";\nimport { SHA256 as Ge, hash as J } from \"@stablelib/sha256\";\nimport * as Q from \"@stablelib/x25519\";\nimport { toString as d, fromString as l, concat as Z } from \"uint8arrays\";\nimport { detect as ze } from \"detect-browser\";\nimport { fromMiliseconds as X, toMiliseconds as D, FIVE_MINUTES as Ye } from \"@walletconnect/time\";\nimport { getDocument as We, getNavigator as ee, getLocation as ne } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as Je } from \"@walletconnect/window-metadata\";\nimport * as T from \"query-string\";\nimport { RELAY_JSONRPC as Qe } from \"@walletconnect/relay-api\";\nconst P = \":\";\nfunction te(e) {\n  const [n, t] = e.split(P);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction re(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(P);\n}\nfunction $(e) {\n  const [n, t, r] = e.split(P);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction oe(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(P);\n}\nfunction j(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction se(e) {\n  const {\n    address: n\n  } = $(e);\n  return n;\n}\nfunction ie(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = $(e);\n  return re({\n    namespace: n,\n    reference: t\n  });\n}\nfunction Ze(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = te(n);\n  return oe({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction Xe(e) {\n  return j(e, se);\n}\nfunction ce(e) {\n  return j(e, ie);\n}\nfunction en(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\nfunction nn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ce(o.accounts));\n  }), t;\n}\nfunction tn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.chains);\n  }), t;\n}\nconst U = e => e?.split(\":\"),\n  ae = e => {\n    const n = e && U(e);\n    if (n) return n[3];\n  },\n  rn = e => {\n    const n = e && U(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  ue = e => {\n    const n = e && U(e);\n    if (n) return n.pop();\n  },\n  on = (e, n) => {\n    const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n      r = ue(n),\n      o = e.statement,\n      s = `URI: ${e.aud}`,\n      i = `Version: ${e.version}`,\n      u = `Chain ID: ${ae(n)}`,\n      f = `Nonce: ${e.nonce}`,\n      g = `Issued At: ${e.iat}`,\n      O = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(p => `- ${p}`).join(`\n`)}` : void 0;\n    return [t, r, \"\", o, \"\", s, i, u, f, g, O].filter(p => p != null).join(`\n`);\n  },\n  V = \"base10\",\n  c = \"base16\",\n  R = \"base64pad\",\n  _ = \"utf8\",\n  M = 0,\n  N = 1,\n  sn = 0,\n  de = 1,\n  K = 12,\n  k = 32;\nfunction cn() {\n  const e = Q.generateKeyPair();\n  return {\n    privateKey: d(e.secretKey, c),\n    publicKey: d(e.publicKey, c)\n  };\n}\nfunction an() {\n  const e = W(k);\n  return d(e, c);\n}\nfunction un(e, n) {\n  const t = Q.sharedKey(l(e, c), l(n, c)),\n    r = new Be(Ge, t).expand(k);\n  return d(r, c);\n}\nfunction dn(e) {\n  const n = J(l(e, c));\n  return d(n, c);\n}\nfunction ln(e) {\n  const n = J(l(e, _));\n  return d(n, c);\n}\nfunction le(e) {\n  return l(`${e}`, V);\n}\nfunction S(e) {\n  return Number(d(e, V));\n}\nfunction fn(e) {\n  const n = le(typeof e.type < \"u\" ? e.type : M);\n  if (S(n) === N && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? l(e.senderPublicKey, c) : void 0,\n    r = typeof e.iv < \"u\" ? l(e.iv, c) : W(K),\n    o = new Y(l(e.symKey, c)).seal(r, l(e.message, _));\n  return fe({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction pn(e) {\n  const n = new Y(l(e.symKey, c)),\n    {\n      sealed: t,\n      iv: r\n    } = L(e.encoded),\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return d(o, _);\n}\nfunction fe(e) {\n  if (S(e.type) === N) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return d(Z([e.type, e.senderPublicKey, e.iv, e.sealed]), R);\n  }\n  return d(Z([e.type, e.iv, e.sealed]), R);\n}\nfunction L(e) {\n  const n = l(e, R),\n    t = n.slice(sn, de),\n    r = de;\n  if (S(t) === N) {\n    const u = r + k,\n      f = u + K,\n      g = n.slice(r, u),\n      O = n.slice(u, f),\n      p = n.slice(f);\n    return {\n      type: t,\n      sealed: p,\n      iv: O,\n      senderPublicKey: g\n    };\n  }\n  const o = r + K,\n    s = n.slice(r, o),\n    i = n.slice(o);\n  return {\n    type: t,\n    sealed: i,\n    iv: s\n  };\n}\nfunction mn(e, n) {\n  const t = L(e);\n  return pe({\n    type: S(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? d(t.senderPublicKey, c) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\nfunction pe(e) {\n  const n = e?.type || M;\n  if (n === N) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction yn(e) {\n  return e.type === N && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar En = Object.defineProperty,\n  me = Object.getOwnPropertySymbols,\n  gn = Object.prototype.hasOwnProperty,\n  hn = Object.prototype.propertyIsEnumerable,\n  ye = (e, n, t) => n in e ? En(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Ee = (e, n) => {\n    for (var t in n || (n = {})) gn.call(n, t) && ye(e, t, n[t]);\n    if (me) for (var t of me(n)) hn.call(n, t) && ye(e, t, n[t]);\n    return e;\n  };\nconst ge = \"ReactNative\",\n  v = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  A = \" \",\n  Nn = \":\",\n  he = \"/\",\n  x = 2,\n  vn = 1e3,\n  Ne = \"js\";\nfunction F() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction ve() {\n  return !We() && !!ee() && navigator.product === ge;\n}\nfunction be() {\n  return !F() && !!ee();\n}\nfunction H() {\n  return ve() ? v.reactNative : F() ? v.node : be() ? v.browser : v.unknown;\n}\nfunction Oe(e, n) {\n  let t = T.parse(e);\n  return t = Ee(Ee({}, t), n), e = T.stringify(t), e;\n}\nfunction bn() {\n  return Je() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction On(e, n) {\n  var t;\n  const r = H(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = ne()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction Se() {\n  const e = ze();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Ie() {\n  var e;\n  const n = H();\n  return n === v.browser ? [n, ((e = ne()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Te(e, n, t) {\n  const r = Se(),\n    o = Ie();\n  return [[e, n].join(\"-\"), [Ne, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction Sn(_ref) {\n  let {\n    protocol: e,\n    version: n,\n    relayUrl: t,\n    sdkVersion: r,\n    auth: o,\n    projectId: s\n  } = _ref;\n  const i = t.split(\"?\"),\n    u = Te(e, n, r),\n    f = {\n      auth: o,\n      ua: u,\n      projectId: s\n    },\n    g = Oe(i[1] || \"\", f);\n  return i[0] + \"?\" + g;\n}\nfunction In(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Tn(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\nfunction Pe(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return Ue(e.split(he), n);\n}\nfunction Pn(e) {\n  return Pe(e).join(A);\n}\nfunction m(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\nfunction Ue(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction Un(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction Rn(e) {\n  return new Map(Object.entries(e));\n}\nfunction _n(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\nconst An = e => e;\nfunction Re(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\nfunction wn(e) {\n  return e.split(A).map(n => Re(n)).join(A);\n}\nfunction Cn(e, n) {\n  return X((n || Date.now()) + D(e));\n}\nfunction Dn(e) {\n  return X(Date.now()) >= D(e);\n}\nfunction $n(e) {\n  const n = D(e || Ye);\n  let t, r, o;\n  return {\n    resolve: s => {\n      o && t && (clearTimeout(o), t(s));\n    },\n    reject: s => {\n      o && r && (clearTimeout(o), r(s));\n    },\n    done: () => new Promise((s, i) => {\n      o = setTimeout(i, n), t = s, r = i;\n    })\n  };\n}\nfunction jn(e, n) {\n  return new Promise(async (t, r) => {\n    const o = setTimeout(() => r(), n),\n      s = await e;\n    clearTimeout(o), t(s);\n  });\n}\nfunction q(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction Vn(e) {\n  return q(\"topic\", e);\n}\nfunction Mn(e) {\n  return q(\"id\", e);\n}\nfunction Kn(e) {\n  const [n, t] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\nfunction kn(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\nconst _e = \"irn\";\nfunction Ln(e) {\n  return e?.relay || {\n    protocol: _e\n  };\n}\nfunction xn(e) {\n  const n = Qe[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\nvar Fn = Object.defineProperty,\n  Ae = Object.getOwnPropertySymbols,\n  Hn = Object.prototype.hasOwnProperty,\n  qn = Object.prototype.propertyIsEnumerable,\n  we = (e, n, t) => n in e ? Fn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Bn = (e, n) => {\n    for (var t in n || (n = {})) Hn.call(n, t) && we(e, t, n[t]);\n    if (Ae) for (var t of Ae(n)) qn.call(n, t) && we(e, t, n[t]);\n    return e;\n  };\nfunction Ce(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n        i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\nfunction Gn(e) {\n  const n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    i = T.parse(s);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: Ce(i)\n  };\n}\nfunction De(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction zn(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + T.stringify(Bn({\n    symKey: e.symKey\n  }, De(e.relay)));\n}\nfunction b(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\nfunction $e(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...b(t.accounts));\n  }), n;\n}\nfunction je(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    b(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\nfunction Ve(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    b(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\nfunction Yn(e, n) {\n  const t = He(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(i => `${i.split(\":\")[0]}:${i.split(\":\")[1]}`)\n  };\n  return r;\n}\nconst Wn = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Jn = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction y(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Jn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction h(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Wn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction I(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction B(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction E(e) {\n  return typeof e > \"u\";\n}\nfunction a(e, n) {\n  return n && E(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\nfunction w(e, n) {\n  return n && E(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction Qn(e, n) {\n  const {\n      requiredNamespaces: t\n    } = n,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  let s = !0;\n  return m(o, r) ? (r.forEach(i => {\n    const {\n        accounts: u,\n        methods: f,\n        events: g\n      } = e.namespaces[i],\n      O = b(u),\n      p = t[i];\n    (!m(p.chains, O) || !m(p.methods, f) || !m(p.events, g)) && (s = !1);\n  }), s) : !1;\n}\nfunction C(e) {\n  return a(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction Me(e) {\n  if (a(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && C(t);\n    }\n  }\n  return !1;\n}\nfunction Zn(e) {\n  if (a(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\nfunction Xn(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\nfunction et(e) {\n  return e?.topic;\n}\nfunction nt(e, n) {\n  let t = null;\n  return a(e?.publicKey, !1) || (t = y(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\nfunction G(e) {\n  let n = !0;\n  return I(e) ? e.length && (n = e.every(t => a(t, !1))) : n = !1, n;\n}\nfunction Ke(e, n, t) {\n  let r = null;\n  return I(n) ? n.forEach(o => {\n    r || (!C(o) || !o.includes(e)) && (r = h(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : r = h(\"UNSUPPORTED_CHAINS\", `${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`), r;\n}\nfunction ke(e, n) {\n  let t = null;\n  return Object.entries(e).forEach(_ref2 => {\n    let [r, o] = _ref2;\n    if (t) return;\n    const s = Ke(r, o?.chains, `${n} requiredNamespace`);\n    s && (t = s);\n  }), t;\n}\nfunction Le(e, n) {\n  let t = null;\n  return I(e) ? e.forEach(r => {\n    t || Me(r) || (t = h(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = h(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction xe(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = Le(r?.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction Fe(e, n) {\n  let t = null;\n  return G(e?.methods) ? G(e?.events) || (t = h(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = h(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction z(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = Fe(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction tt(e, n) {\n  let t = null;\n  if (e && B(e)) {\n    const r = z(e, n);\n    r && (t = r);\n    const o = ke(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", `${n}, requiredNamespaces should be an object with data`);\n  return t;\n}\nfunction He(e, n) {\n  let t = null;\n  if (e && B(e)) {\n    const r = z(e, n);\n    r && (t = r);\n    const o = xe(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n  return t;\n}\nfunction qe(e) {\n  return a(e.protocol, !0);\n}\nfunction rt(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && I(e) && e.length && e.forEach(r => {\n    t = qe(r);\n  }), t;\n}\nfunction ot(e) {\n  return typeof e == \"number\";\n}\nfunction st(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction it(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !w(e.code, !1) || !e.message || !a(e.message, !1));\n}\nfunction ct(e) {\n  return !(E(e) || !a(e.method, !1));\n}\nfunction at(e) {\n  return !(E(e) || E(e.result) && E(e.error) || !w(e.id, !1) || !a(e.jsonrpc, !1));\n}\nfunction ut(e) {\n  return !(E(e) || !a(e.name, !1));\n}\nfunction dt(e, n) {\n  return !(!C(n) || !$e(e).includes(n));\n}\nfunction lt(e, n, t) {\n  return a(t, !1) ? je(e, n).includes(t) : !1;\n}\nfunction ft(e, n, t) {\n  return a(t, !1) ? Ve(e, n).includes(t) : !1;\n}\nfunction pt(e, n, t) {\n  let r = null;\n  const o = Object.keys(e),\n    s = Object.keys(n);\n  return m(o, s) ? o.forEach(i => {\n    if (r) return;\n    const u = e[i].chains,\n      f = b(n[i].accounts);\n    m(u, f) ? m(e[i].methods, n[i].methods) ? m(e[i].events, n[i].events) || (r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy requiredNamespaces events for ${i}`)) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy requiredNamespaces methods for ${i}`) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy requiredNamespaces chains for ${i}`);\n  }) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces`), r;\n}\nfunction mt(e, n) {\n  return w(e, !1) && e <= n.max && e >= n.min;\n}\nexport { V as BASE10, c as BASE16, R as BASE64, Nn as COLON, x as DEFAULT_DEPTH, A as EMPTY_SPACE, v as ENV_MAP, vn as ONE_THOUSAND, ge as REACT_NATIVE_PRODUCT, _e as RELAYER_DEFAULT_PROTOCOL, Ne as SDK_TYPE, he as SLASH, M as TYPE_0, N as TYPE_1, _ as UTF8, Oe as appendToQueryString, Tn as assertType, Cn as calcExpiry, wn as capitalize, Re as capitalizeWord, $n as createDelayedPromise, jn as createExpiringPromise, S as decodeTypeByte, pn as decrypt, un as deriveSymKey, L as deserialize, le as encodeTypeByte, fn as encrypt, kn as engineEvent, An as enumify, oe as formatAccountId, Ze as formatAccountWithChain, re as formatChainId, q as formatExpirerTarget, Mn as formatIdTarget, on as formatMessage, Pn as formatMessageContext, De as formatRelayParams, Sn as formatRelayRpcUrl, Vn as formatTopicTarget, Te as formatUA, zn as formatUri, cn as generateKeyPair, an as generateRandomBytes32, b as getAccountsChains, en as getAccountsFromNamespaces, se as getAddressFromAccount, Xe as getAddressesFromAccounts, bn as getAppMetadata, ie as getChainFromAccount, ce as getChainsFromAccounts, nn as getChainsFromNamespaces, tn as getChainsFromRequiredNamespaces, ue as getDidAddress, U as getDidAddressSegments, ae as getDidChainId, H as getEnvironment, In as getHttpUrl, y as getInternalError, Ie as getJavascriptID, Se as getJavascriptOS, Ue as getLastItems, rn as getNamespacedDidChainId, $e as getNamespacesChains, Ve as getNamespacesEventsForChainId, je as getNamespacesMethodsForChainId, On as getRelayClientMetadata, xn as getRelayProtocolApi, Ln as getRelayProtocolName, Yn as getRequiredNamespacesFromNamespaces, h as getSdkError, j as getUniqueValues, m as hasOverlap, dn as hashKey, ln as hashMessage, be as isBrowser, pt as isConformingNamespaces, Dn as isExpired, F as isNode, Xn as isProposalStruct, ve as isReactNative, Qn as isSessionCompatible, et as isSessionStruct, yn as isTypeOneEnvelope, E as isUndefined, Me as isValidAccountId, Le as isValidAccounts, Fe as isValidActions, I as isValidArray, C as isValidChainId, Ke as isValidChains, nt as isValidController, it as isValidErrorReason, ut as isValidEvent, ot as isValidId, xe as isValidNamespaceAccounts, z as isValidNamespaceActions, ke as isValidNamespaceChains, G as isValidNamespaceMethodsOrEvents, He as isValidNamespaces, dt as isValidNamespacesChainId, ft as isValidNamespacesEvent, lt as isValidNamespacesRequest, w as isValidNumber, B as isValidObject, st as isValidParams, qe as isValidRelay, rt as isValidRelays, ct as isValidRequest, mt as isValidRequestExpiry, tt as isValidRequiredNamespaces, at as isValidResponse, a as isValidString, Zn as isValidUrl, _n as mapEntries, Un as mapToObj, Rn as objToMap, $ as parseAccountId, te as parseChainId, Pe as parseContextNames, Kn as parseExpirerTarget, Ce as parseRelayParams, Gn as parseUri, fe as serialize, mn as validateDecoding, pe as validateEncoding };","map":{"version":3,"names":[],"sources":["/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/caip.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/cacao.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/crypto.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/misc.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/relay.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/uri.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/namespaces.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/errors.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/src/validators.ts"],"sourcesContent":["import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...ns.chains);\n  });\n  return chains;\n}\n","export interface CacaoPayload {\n  iss: string;\n  domain: string;\n  aud: string;\n  version: string;\n  nonce: string;\n  iat: string;\n  nbf?: string;\n  exp?: string;\n  statement?: string;\n  requestId?: string;\n  resources?: string[];\n}\n\nexport interface CacaoHeader {\n  t: \"eip4361\";\n}\n\nexport interface CacaoSignature {\n  t: \"eip191\" | \"eip1271\";\n  s: string;\n  m?: string;\n}\n\nexport interface Cacao {\n  h: CacaoHeader;\n  p: CacaoPayload;\n  s: CacaoSignature;\n}\n\nexport const getDidAddressSegments = (iss: string) => {\n  return iss?.split(\":\");\n};\n\nexport const getDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[3];\n  }\n  return undefined;\n};\n\nexport const getNamespacedDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n};\n\nexport const getDidAddress = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n};\n\nexport const formatMessage = (cacao: CacaoPayload, iss: string) => {\n  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n  const walletAddress = getDidAddress(iss);\n  const statement = cacao.statement;\n  const uri = `URI: ${cacao.aud}`;\n  const version = `Version: ${cacao.version}`;\n  const chainId = `Chain ID: ${getDidChainId(iss)}`;\n  const nonce = `Nonce: ${cacao.nonce}`;\n  const issuedAt = `Issued At: ${cacao.iat}`;\n  const resources =\n    cacao.resources && cacao.resources.length > 0\n      ? `Resources:\\n${cacao.resources.map((resource) => `- ${resource}`).join(\"\\n\")}`\n      : undefined;\n\n  const message = [\n    header,\n    walletAddress,\n    ``,\n    statement,\n    ``,\n    uri,\n    version,\n    chainId,\n    nonce,\n    issuedAt,\n    resources,\n  ]\n    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n    .join(\"\\n\");\n\n  return message;\n};\n","import { ChaCha20Poly1305 } from \"@stablelib/chacha20poly1305\";\nimport { HKDF } from \"@stablelib/hkdf\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { hash, SHA256 } from \"@stablelib/sha256\";\nimport * as x25519 from \"@stablelib/x25519\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { concat, fromString, toString } from \"uint8arrays\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const keyPair = x25519.generateKeyPair();\n  return {\n    privateKey: toString(keyPair.secretKey, BASE16),\n    publicKey: toString(keyPair.publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.sharedKey(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n  );\n  const hkdf = new HKDF(SHA256, sharedKey);\n  const symKey = hkdf.expand(KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = hash(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = hash(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const sealed = box.seal(iv, fromString(params.message, UTF8));\n  return serialize({ type, sealed, iv, senderPublicKey });\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const { sealed, iv } = deserialize(params.encoded);\n  const message = box.open(iv, sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      BASE64,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), BASE64);\n}\n\nexport function deserialize(encoded: string): CryptoTypes.EncodingParams {\n  const bytes = fromString(encoded, BASE64);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize(encoded);\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n","import { detect } from \"detect-browser\";\nimport { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  SignClientTypes,\n  RelayerClientMetadata,\n  EngineTypes,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { getDocument, getLocation, getNavigator } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata } from \"@walletconnect/window-metadata\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-utils\";\nimport * as qs from \"query-string\";\n\n// -- constants -----------------------------------------//\n\nexport const REACT_NATIVE_PRODUCT = \"ReactNative\";\n\nexport const ENV_MAP = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\",\n};\n\nexport const EMPTY_SPACE = \" \";\n\nexport const COLON = \":\";\n\nexport const SLASH = \"/\";\n\nexport const DEFAULT_DEPTH = 2;\n\nexport const ONE_THOUSAND = 1000;\n\nexport const SDK_TYPE = \"js\";\n\n// -- env -----------------------------------------------//\n\nexport function isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isReactNative(): boolean {\n  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;\n}\n\nexport function isBrowser(): boolean {\n  return !isNode() && !!getNavigator();\n}\n\nexport function getEnvironment(): string {\n  if (isReactNative()) return ENV_MAP.reactNative;\n  if (isNode()) return ENV_MAP.node;\n  if (isBrowser()) return ENV_MAP.browser;\n  return ENV_MAP.unknown;\n}\n\n// -- query -----------------------------------------------//\n\nexport function appendToQueryString(queryString: string, newQueryParams: any): string {\n  let queryParams = qs.parse(queryString);\n\n  queryParams = { ...queryParams, ...newQueryParams };\n\n  queryString = qs.stringify(queryParams);\n\n  return queryString;\n}\n\n// -- metadata ----------------------------------------------//\n\nexport function getAppMetadata(): SignClientTypes.Metadata {\n  return (\n    getWindowMetadata() || {\n      name: \"\",\n      description: \"\",\n      url: \"\",\n      icons: [\"\"],\n    }\n  );\n}\n\nexport function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {\n  const env = getEnvironment();\n\n  const metadata: RelayerClientMetadata = { protocol, version, env };\n  if (env === \"browser\") {\n    metadata.host = getLocation()?.host || \"unknown\";\n  }\n  return metadata;\n}\n\n// -- rpcUrl ----------------------------------------------//\n\nexport function getJavascriptOS() {\n  const info = detect();\n  if (info === null) return \"unknown\";\n  const os = info.os ? info.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  if (info.type === \"browser\") {\n    return [os, info.name, info.version].join(\"-\");\n  }\n  return [os, info.version].join(\"-\");\n}\n\nexport function getJavascriptID() {\n  const env = getEnvironment();\n  return env === ENV_MAP.browser ? [env, getLocation()?.host || \"unknown\"].join(\":\") : env;\n}\n\nexport function formatUA(protocol: string, version: number, sdkVersion: string) {\n  const os = getJavascriptOS();\n  const id = getJavascriptID();\n  return [[protocol, version].join(\"-\"), [SDK_TYPE, sdkVersion].join(\"-\"), os, id].join(\"/\");\n}\nconsole;\n\nexport function formatRelayRpcUrl({\n  protocol,\n  version,\n  relayUrl,\n  sdkVersion,\n  auth,\n  projectId,\n}: RelayerTypes.RpcUrlParams) {\n  const splitUrl = relayUrl.split(\"?\");\n  const ua = formatUA(protocol, version, sdkVersion);\n  const params = { auth, ua, projectId };\n  const queryString = appendToQueryString(splitUrl[1] || \"\", params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport function getHttpUrl(url: string) {\n  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url\n  const matches = url.match(/^[^:]+(?=:\\/\\/)/gi) || [];\n  let protocol = matches[0];\n  const domain = typeof protocol !== \"undefined\" ? url.split(\"://\")[1] : url;\n  protocol = protocol === \"wss\" ? \"https\" : \"http\";\n  return [protocol, domain].join(\"://\");\n}\n\n// -- assert ------------------------------------------------- //\n\nexport function assertType(obj: any, key: string, type: string) {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\n// -- context ------------------------------------------------- //\n\nexport function parseContextNames(context: string, depth = DEFAULT_DEPTH) {\n  return getLastItems(context.split(SLASH), depth);\n}\n\nexport function formatMessageContext(context: string): string {\n  return parseContextNames(context).join(EMPTY_SPACE);\n}\n\n// -- array ------------------------------------------------- //\n\nexport function hasOverlap(a: any[], b: any[]): boolean {\n  const matches = a.filter((x) => b.includes(x));\n  return matches.length === a.length;\n}\n\nexport function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {\n  return arr.slice(Math.max(arr.length - depth, 0));\n}\n\n// -- map ------------------------------------------------- //\n\nexport function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {\n  return Object.fromEntries(map.entries());\n}\n\nexport function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {\n  return new Map<string, T>(Object.entries<T>(obj));\n}\n\nexport function mapEntries<A = any, B = any>(\n  obj: Record<string, A>,\n  cb: (x: A) => B,\n): Record<string, B> {\n  const res = {};\n  Object.keys(obj).forEach((key) => {\n    res[key] = cb(obj[key]);\n  });\n  return res;\n}\n\n// -- enum ------------------------------------------------- //\n\n// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nexport const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;\n\n// -- string ------------------------------------------------- //\n\nexport function capitalizeWord(word: string) {\n  return word.trim().replace(/^\\w/, (c) => c.toUpperCase());\n}\n\nexport function capitalize(str: string) {\n  return str\n    .split(EMPTY_SPACE)\n    .map((w) => capitalizeWord(w))\n    .join(EMPTY_SPACE);\n}\n\n// -- time ------------------------------------------------- //\n\nexport function calcExpiry(ttl: number, now?: number): number {\n  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));\n}\n\nexport function isExpired(expiry: number) {\n  return fromMiliseconds(Date.now()) >= toMiliseconds(expiry);\n}\n\n// -- promises --------------------------------------------- //\nexport function createDelayedPromise<T>(expiry?: number | undefined) {\n  const timeout = toMiliseconds(expiry || FIVE_MINUTES);\n  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);\n  let cacheReject: undefined | ((value?: ErrorResponse) => void);\n  let cacheTimeout: undefined | NodeJS.Timeout;\n\n  const done = () =>\n    new Promise<T>((promiseResolve, promiseReject) => {\n      cacheTimeout = setTimeout(promiseReject, timeout);\n      cacheResolve = promiseResolve;\n      cacheReject = promiseReject;\n    });\n  const resolve = (value?: T) => {\n    if (cacheTimeout && cacheResolve) {\n      clearTimeout(cacheTimeout);\n      cacheResolve(value as T);\n    }\n  };\n  const reject = (value?: ErrorResponse) => {\n    if (cacheTimeout && cacheReject) {\n      clearTimeout(cacheTimeout);\n      cacheReject(value);\n    }\n  };\n\n  return {\n    resolve,\n    reject,\n    done,\n  };\n}\n\nexport function createExpiringPromise<T>(promise: Promise<T>, expiry: number) {\n  return new Promise(async (resolve, reject) => {\n    const timeout = setTimeout(() => reject(), expiry);\n    const res = await promise;\n    clearTimeout(timeout);\n    resolve(res);\n  });\n}\n\n// -- expirer --------------------------------------------- //\n\nexport function formatExpirerTarget(type: \"topic\" | \"id\", value: string | number): string {\n  if (typeof value === \"string\" && value.startsWith(`${type}:`)) return value;\n  if (type.toLowerCase() === \"topic\") {\n    if (typeof value !== \"string\")\n      throw new Error(`Value must be \"string\" for expirer target type: topic`);\n    return `topic:${value}`;\n  } else if (type.toLowerCase() === \"id\") {\n    if (typeof value !== \"number\")\n      throw new Error(`Value must be \"number\" for expirer target type: id`);\n    return `id:${value}`;\n  }\n  throw new Error(`Unknown expirer target type: ${type}`);\n}\n\nexport function formatTopicTarget(topic: string): string {\n  return formatExpirerTarget(\"topic\", topic);\n}\n\nexport function formatIdTarget(id: number): string {\n  return formatExpirerTarget(\"id\", id);\n}\n\nexport function parseExpirerTarget(target: string) {\n  const [type, value] = target.split(\":\");\n  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };\n  if (type === \"topic\" && typeof value === \"string\") {\n    parsed.topic = value;\n  } else if (type === \"id\" && Number.isInteger(Number(value))) {\n    parsed.id = Number(value);\n  } else {\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);\n  }\n\n  return parsed;\n}\n\n// -- events ---------------------------------------------- //\n\nexport function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {\n  return `${event}${id ? `:${id}` : \"\"}`;\n}\n","import { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { RelayerTypes } from \"@walletconnect/types\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport function getRelayProtocolName(\n  opts?: RelayerTypes.RequestOptions,\n): RelayerTypes.ProtocolOptions {\n  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\n\nexport function getRelayProtocolApi(protocol: string) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n  return jsonrpc;\n}\n","import * as qs from \"query-string\";\nimport { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const queryParams = qs.parse(queryString);\n  const result = {\n    protocol,\n    topic: requiredValues[0],\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n  };\n  return result;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const k = prefix + delimiter + key;\n    if (relay[key]) {\n      params[k] = relay[key];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  return (\n    `${params.protocol}:${params.topic}@${params.version}?` +\n    qs.stringify({\n      symKey: params.symKey,\n      ...formatRelayParams(params.relay),\n    })\n  );\n}\n","import { ProposalTypes, SessionTypes } from \"@walletconnect/types\";\nimport { isValidNamespaces } from \"./validators\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n  });\n\n  return events;\n}\n\nexport function getRequiredNamespacesFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  caller: string,\n): ProposalTypes.RequiredNamespaces {\n  const validNamespacesError = isValidNamespaces(namespaces, caller);\n  if (validNamespacesError) throw new Error(validNamespacesError.message);\n\n  const required = {};\n  for (const [namespace, values] of Object.entries(namespaces)) {\n    required[namespace] = {\n      methods: values.methods,\n      events: values.events,\n      chains: values.accounts.map((account) => `${account.split(\":\")[0]}:${account.split(\":\")[1]}`),\n    };\n  }\n  return required;\n}\n","/**\n * Types\n */\ntype SdkErrorKey = keyof typeof SDK_ERRORS;\ntype InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nconst SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n  /* ----- PAIRING (10xxx) ----- */\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001,\n  },\n};\n\nconst INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces\";\nimport { getSdkError, getInternalError } from \"./errors\";\nimport { hasOverlap } from \"./misc\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n\n    if (\n      !hasOverlap(requiredNamespace.chains, chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  if (isValidString(value, false)) {\n    try {\n      const url = new URL(value);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(chains)) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain) || !chain.includes(key)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains ${chains} should be an array of strings conforming to \"namespace:chainId\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(key, namespace?.chains, `${method} requiredNamespace`);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, requiredNamespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n  const requiredNamespaceKeys = Object.keys(requiredNamespaces);\n  const namespaceKeys = Object.keys(namespaces);\n\n  if (!hasOverlap(requiredNamespaceKeys, namespaceKeys)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces`,\n    );\n  } else {\n    requiredNamespaceKeys.forEach((key) => {\n      if (error) return;\n\n      const requiredNamespaceChains = requiredNamespaces[key].chains;\n      const namespaceChains = getAccountsChains(namespaces[key].accounts);\n\n      if (!hasOverlap(requiredNamespaceChains, namespaceChains)) {\n        error = getInternalError(\n          \"NON_CONFORMING_NAMESPACES\",\n          `${context} namespaces accounts don't satisfy requiredNamespaces chains for ${key}`,\n        );\n      } else if (!hasOverlap(requiredNamespaces[key].methods, namespaces[key].methods)) {\n        error = getInternalError(\n          \"NON_CONFORMING_NAMESPACES\",\n          `${context} namespaces methods don't satisfy requiredNamespaces methods for ${key}`,\n        );\n      } else if (!hasOverlap(requiredNamespaces[key].events, namespaces[key].events)) {\n        error = getInternalError(\n          \"NON_CONFORMING_NAMESPACES\",\n          `${context} namespaces events don't satisfy requiredNamespaces events for ${key}`,\n        );\n      }\n    });\n  }\n\n  return error;\n}\n\nexport function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {\n  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}