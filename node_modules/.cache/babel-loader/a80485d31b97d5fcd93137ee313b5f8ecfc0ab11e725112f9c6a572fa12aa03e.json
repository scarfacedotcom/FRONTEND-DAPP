{"ast":null,"code":"import m from \"pino\";\nimport f from \"@walletconnect/sign-client\";\nimport { getSdkError as g, isValidArray as P } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions as w } from \"@walletconnect/logger\";\nimport { JsonRpcProvider as a } from \"@walletconnect/jsonrpc-provider\";\nimport c, { HttpConnection as C } from \"@walletconnect/jsonrpc-http-connection\";\nimport I from \"events\";\nfunction y(i) {\n  var t;\n  const e = (t = i[Object.keys(i)[0]]) == null ? void 0 : t.chains[0];\n  return [e.split(\":\")[0], e.split(\":\")[1]];\n}\nfunction r(i, t) {\n  let e;\n  return t.rpcMap && (e = t.rpcMap[O([i])]), e;\n}\nfunction O(i) {\n  return Number(i[0].split(\":\")[1]);\n}\nclass E {\n  constructor(t) {\n    this.name = \"eip155\", this.namespace = t.namespace, this.client = t.client, this.events = t.events, this.httpProviders = this.createHttpProviders(), this.chainId = this.getDefaultChainId();\n  }\n  async request(t) {\n    var e;\n    switch (t.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n      case \"eth_accounts\":\n        return this.getAccounts();\n      case \"wallet_switchEthereumChain\":\n        {\n          const s = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : \"0x0\";\n          return this.setDefaultChain(parseInt(s, 16).toString()), null;\n        }\n      case \"eth_chainId\":\n        return this.getDefaultChainId();\n    }\n    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = parseInt(t), !this.httpProviders[t]) {\n      const s = e || r(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  createHttpProvider(t, e) {\n    const s = e || r(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new C(s));\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return parseInt(t.split(\":\")[1]);\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n}\nclass q {\n  constructor(t) {\n    this.name = \"solana\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || r(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || r(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new c(s));\n  }\n}\nclass H {\n  constructor(t) {\n    this.name = \"cosmos\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || r(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || r(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new c(s));\n  }\n}\nclass $ {\n  constructor(t) {\n    this.name = \"cip34\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || r(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || r(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new c(s));\n  }\n}\nconst h = \"error\",\n  b = \"wss://relay.walletconnect.com\",\n  S = \"wc\",\n  A = \"universal_provider\",\n  p = `${S}@${2}:${A}:`;\nvar N = Object.defineProperty,\n  D = Object.defineProperties,\n  j = Object.getOwnPropertyDescriptors,\n  d = Object.getOwnPropertySymbols,\n  k = Object.prototype.hasOwnProperty,\n  R = Object.prototype.propertyIsEnumerable,\n  l = (i, t, e) => t in i ? N(i, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : i[t] = e,\n  u = (i, t) => {\n    for (var e in t || (t = {})) k.call(t, e) && l(i, e, t[e]);\n    if (d) for (var e of d(t)) R.call(t, e) && l(i, e, t[e]);\n    return i;\n  },\n  _ = (i, t) => D(i, j(t));\nclass o {\n  constructor(t) {\n    this.events = new I(), this.rpcProviders = {}, this.providerOpts = t, this.logger = typeof t?.logger < \"u\" && typeof t?.logger != \"string\" ? t.logger : m(w({\n      level: t?.logger || h\n    }));\n  }\n  static async init(t) {\n    const e = new o(t);\n    return await e.initialize(), e;\n  }\n  async request(t, e) {\n    const [s, n] = this.validateChain(e);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(s).request({\n      request: u({}, t),\n      chainId: `${s}:${n}`,\n      topic: this.session.topic\n    });\n  }\n  sendAsync(t, e, s) {\n    this.request(t, s).then(n => e(null, n)).catch(n => e(n, void 0));\n  }\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces\n    })), await this.requestAccounts();\n  }\n  async disconnect() {\n    var t;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (t = this.session) == null ? void 0 : t.topic,\n      reason: g(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n  async connect(t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    const {\n      namespaces: e\n    } = t;\n    return this.setNamespaces(e), this.createProviders(), await this.cleanupPendingPairings(), t.skipPairing === !0 ? void 0 : await this.pair(t.pairingTopic);\n  }\n  on(t, e) {\n    this.events.on(t, e);\n  }\n  once(t, e) {\n    this.events.once(t, e);\n  }\n  removeListener(t, e) {\n    this.events.removeListener(t, e);\n  }\n  off(t, e) {\n    this.events.off(t, e);\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  async pair(t) {\n    const {\n      uri: e,\n      approval: s\n    } = await this.client.connect({\n      pairingTopic: t,\n      requiredNamespaces: this.namespaces\n    });\n    return e && (this.uri = e, this.events.emit(\"display_uri\", e)), this.session = await s(), this.onSessionUpdate(), this.onConnect(), this.session;\n  }\n  setDefaultChain(t, e) {\n    try {\n      const [s, n] = this.validateChain(t);\n      this.getProvider(s).setDefaultChain(n, e);\n    } catch (s) {\n      if (!/Please call connect/.test(s.message)) throw s;\n    }\n  }\n  async cleanupPendingPairings() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const e = this.client.pairing.getAll();\n    if (P(e)) {\n      for (const s of e) t.deletePairings ? this.client.core.expirer.set(s.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s.topic);\n      this.logger.info(`Inactive pairings cleared: ${e.length}`);\n    }\n  }\n  async checkStorage() {\n    if (this.namespaces = (await this.client.core.storage.getItem(`${p}/namespaces`)) || {}, this.namespaces && this.createProviders(), this.client.session.length) {\n      const t = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[t]), this.onSessionUpdate();\n    }\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), this.checkStorage(), this.registerEventListeners();\n  }\n  async createClient() {\n    this.client = this.providerOpts.client || (await f.init({\n      logger: this.providerOpts.logger || h,\n      relayUrl: this.providerOpts.relayUrl || b,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      name: this.providerOpts.name\n    })), this.logger.trace(\"SignClient Initialized\");\n  }\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    Object.keys(this.namespaces).forEach(t => {\n      switch (t) {\n        case \"eip155\":\n          this.rpcProviders[t] = new E({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[t] = new q({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[t] = new H({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n        case \"polkadot\":\n          break;\n        case \"cip34\":\n          this.rpcProviders[t] = new $({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n      }\n    });\n  }\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", t => {\n      this.events.emit(\"session_ping\", t);\n    }), this.client.on(\"session_event\", t => {\n      const {\n          params: e\n        } = t,\n        {\n          event: s\n        } = e;\n      s.name === \"accountsChanged\" ? this.events.emit(\"accountsChanged\", s.data) : s.name === \"chainChanged\" ? this.onChainChanged(s.data, e.chainId) : this.events.emit(s.name, s.data), this.events.emit(\"session_event\", t);\n    }), this.client.on(\"session_update\", _ref => {\n      let {\n        topic: t,\n        params: e\n      } = _ref;\n      var s;\n      const {\n          namespaces: n\n        } = e,\n        v = (s = this.client) == null ? void 0 : s.session.get(t);\n      this.session = _(u({}, v), {\n        namespaces: n\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: t,\n        params: e\n      });\n    }), this.client.on(\"session_delete\", async t => {\n      await this.cleanup(), this.events.emit(\"session_delete\", t);\n    });\n  }\n  getProvider(t) {\n    if (!this.rpcProviders[t]) throw new Error(`Provider not found: ${t}`);\n    return this.rpcProviders[t];\n  }\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(t => {\n      var e;\n      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);\n    });\n  }\n  setNamespaces(t) {\n    if (!t || !Object.keys(t).length) throw new Error(\"Namespaces must be not empty\");\n    this.client.core.storage.setItem(`${p}/namespaces`, t), this.namespaces = t;\n  }\n  validateChain(t) {\n    const [e, s] = t?.split(\":\") || [\"\", \"\"];\n    if (e && !Object.keys(this.namespaces).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);\n    return !e || !s ? y(this.namespaces) : [e, s];\n  }\n  async requestAccounts() {\n    const [t] = this.validateChain();\n    return await this.getProvider(t).requestAccounts();\n  }\n  onChainChanged(t, e) {\n    const [s, n] = this.validateChain(e);\n    this.getProvider(s).setDefaultChain(n), this.events.emit(\"chainChanged\", t);\n  }\n  onConnect() {\n    this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n  async cleanup() {\n    this.session = void 0, await this.cleanupPendingPairings({\n      deletePairings: !0\n    });\n  }\n}\nconst U = o;\nexport { U as UniversalProvider, o as default };","map":{"version":3,"names":[],"sources":["/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/src/utils/misc.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/src/providers/eip155.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/src/providers/solana.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/src/providers/cosmos.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/src/providers/cardano.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/src/constants/values.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/src/UniversalProvider.ts","/home/ubuntu/Documents/React-Token/React/node_modules/@walletconnect/universal-provider/src/index.ts"],"sourcesContent":["import { NamespaceConfig, Namespace } from \"../types\";\n\nexport function getChainFromNamespaces(namespaces: NamespaceConfig): [string, string] {\n  const chain = namespaces[Object.keys(namespaces)[0]]?.chains[0];\n  return [chain.split(\":\")[0], chain.split(\":\")[1]];\n}\n\nexport function getRpcUrl(chainId: string, rpc: Namespace): string | undefined {\n  let rpcUrl: string | undefined;\n  if (rpc.rpcMap) {\n    rpcUrl = rpc.rpcMap[getChainId([chainId])];\n  }\n  return rpcUrl;\n}\n\nexport function getChainId(chains: string[]): number {\n  return Number(chains[0].split(\":\")[1]);\n}\n","import Client from \"@walletconnect/sign-client\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport { HttpConnection } from \"@walletconnect/jsonrpc-http-connection\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\n\nimport {\n  IProvider,\n  RpcProvidersMap,\n  SubProviderOpts,\n  RequestParams,\n  SessionNamespace,\n} from \"../types\";\n\nimport { getRpcUrl } from \"../utils\";\nimport EventEmitter from \"events\";\n\nclass Eip155Provider implements IProvider {\n  public name = \"eip155\";\n  public client: Client;\n  // the active chainId on the dapp\n  public chainId: number;\n  public namespace: SessionNamespace;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.client = opts.client;\n    this.events = opts.events;\n    this.httpProviders = this.createHttpProviders();\n    this.chainId = this.getDefaultChainId();\n  }\n\n  public async request<T = unknown>(args: RequestParams): Promise<T> {\n    switch (args.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts() as any;\n      case \"eth_accounts\":\n        return this.getAccounts() as any;\n      case \"wallet_switchEthereumChain\": {\n        const newChainId = args.request.params ? args.request.params[0]?.chainId : \"0x0\";\n        this.setDefaultChain(parseInt(newChainId, 16).toString());\n        return null as any;\n      }\n      case \"eth_chainId\":\n        return this.getDefaultChainId() as any;\n      default:\n        break;\n    }\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = parseInt(chainId);\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc));\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain);\n    });\n    return http;\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private getDefaultChainId(): number {\n    if (this.chainId) return this.chainId;\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return parseInt(chainId.split(\":\")[1]);\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n}\n\nexport default Eip155Provider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getRpcUrl } from \"../utils\";\n\nclass SolanaProvider implements IProvider {\n  public name = \"solana\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = opts.events;\n    this.client = opts.client;\n    this.chainId = this.getDefaultChainId();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain);\n    });\n    return http;\n  }\n\n  private getDefaultChainId(): string {\n    if (this.chainId) return this.chainId;\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc));\n    return http;\n  }\n}\n\nexport default SolanaProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getRpcUrl } from \"../utils\";\n\nclass CosmosProvider implements IProvider {\n  public name = \"cosmos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = opts.events;\n    this.client = opts.client;\n    this.chainId = this.getDefaultChainId();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain);\n    });\n    return http;\n  }\n\n  private getDefaultChainId(): string {\n    if (this.chainId) return this.chainId;\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc));\n    return http;\n  }\n}\n\nexport default CosmosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getRpcUrl } from \"../utils\";\n\nclass CardanoProvider implements IProvider {\n  public name = \"cip34\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = opts.events;\n    this.client = opts.client;\n    this.chainId = this.getDefaultChainId();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain);\n    });\n    return http;\n  }\n\n  private getDefaultChainId(): string {\n    if (this.chainId) return this.chainId;\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc));\n    return http;\n  }\n}\n\nexport default CardanoProvider;\n","export const LOGGER = \"error\";\n\nexport const RELAY_URL = \"wss://relay.walletconnect.com\";\n\nexport const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"universal_provider\";\n\nexport const STORAGE = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\n","import pino from \"pino\";\nimport SignClient from \"@walletconnect/sign-client\";\nimport { ProviderAccounts } from \"eip1193-provider\";\nimport { SessionTypes } from \"@walletconnect/types\";\nimport { getSdkError, isValidArray } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions, Logger } from \"@walletconnect/logger\";\nimport Eip155Provider from \"./providers/eip155\";\nimport SolanaProvider from \"./providers/solana\";\nimport CosmosProvider from \"./providers/cosmos\";\nimport CardanoProvider from \"./providers/cardano\";\nimport { getChainFromNamespaces } from \"./utils\";\nimport {\n  IUniversalProvider,\n  IProvider,\n  RpcProviderMap,\n  ConnectParams,\n  RequestArguments,\n  UniversalProviderOpts,\n  NamespaceConfig,\n  PairingsCleanupOpts,\n} from \"./types\";\n\nimport { RELAY_URL, LOGGER, STORAGE } from \"./constants\";\nimport EventEmitter from \"events\";\n\nexport class UniversalProvider implements IUniversalProvider {\n  public client!: SignClient;\n  public namespaces!: NamespaceConfig;\n  public events: EventEmitter = new EventEmitter();\n  public rpcProviders: RpcProviderMap = {};\n  public session?: SessionTypes.Struct;\n  public providerOpts: UniversalProviderOpts;\n  public logger: Logger;\n  public uri: string | undefined;\n\n  static async init(opts: UniversalProviderOpts) {\n    const provider = new UniversalProvider(opts);\n    await provider.initialize();\n    return provider;\n  }\n\n  constructor(opts: UniversalProviderOpts) {\n    this.providerOpts = opts;\n    this.logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || LOGGER }));\n  }\n\n  public async request<T = unknown>(\n    args: RequestArguments,\n    chain?: string | undefined,\n  ): Promise<T> {\n    const [namespace, chainId] = this.validateChain(chain);\n\n    if (!this.session) {\n      throw new Error(\"Please call connect() before request()\");\n    }\n\n    return await this.getProvider(namespace).request({\n      request: {\n        ...args,\n      },\n      chainId: `${namespace}:${chainId}`,\n      topic: this.session.topic,\n    });\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: any) => void,\n    chain?: string | undefined,\n  ): void {\n    this.request(args, chain)\n      .then((response) => callback(null, response))\n      .catch((error) => callback(error, undefined));\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    if (!this.session) {\n      await this.connect({ namespaces: this.namespaces });\n    }\n    const accounts = await this.requestAccounts();\n    return accounts as ProviderAccounts;\n  }\n\n  public async disconnect(): Promise<void> {\n    if (!this.session) {\n      throw new Error(\"Please call connect() before enable()\");\n    }\n    await this.client.disconnect({\n      topic: this.session?.topic,\n      reason: getSdkError(\"USER_DISCONNECTED\"),\n    });\n    await this.cleanup();\n  }\n\n  public async connect(opts: ConnectParams): Promise<SessionTypes.Struct | undefined> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    const { namespaces } = opts;\n    this.setNamespaces(namespaces);\n    this.createProviders();\n    await this.cleanupPendingPairings();\n    return opts.skipPairing === true ? undefined : await this.pair(opts.pairingTopic);\n  }\n\n  public on(event: any, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  public async pair(pairingTopic: string | undefined): Promise<SessionTypes.Struct> {\n    const { uri, approval } = await this.client.connect({\n      pairingTopic,\n      requiredNamespaces: this.namespaces,\n    });\n\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n\n    this.session = await approval();\n    this.onSessionUpdate();\n    this.onConnect();\n    return this.session;\n  }\n\n  public setDefaultChain(chain: string, rpcUrl?: string | undefined) {\n    try {\n      const [namespace, chainId] = this.validateChain(chain);\n      this.getProvider(namespace).setDefaultChain(chainId, rpcUrl);\n    } catch (error) {\n      // ignore the error if the fx is used prematurely before namespaces are set\n      if (!/Please call connect/.test((error as Error).message)) throw error;\n    }\n  }\n\n  public async cleanupPendingPairings(opts: PairingsCleanupOpts = {}): Promise<void> {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const inactivePairings = this.client.pairing.getAll();\n\n    if (!isValidArray(inactivePairings)) return;\n\n    for (const pairing of inactivePairings) {\n      if (opts.deletePairings) {\n        this.client.core.expirer.set(pairing.topic, 0);\n      } else {\n        await this.client.core.relayer.subscriber.unsubscribe(pairing.topic);\n      }\n    }\n\n    this.logger.info(`Inactive pairings cleared: ${inactivePairings.length}`);\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async checkStorage() {\n    this.namespaces =\n      ((await this.client.core.storage.getItem(`${STORAGE}/namespaces`)) as NamespaceConfig) || {};\n    if (this.namespaces) {\n      this.createProviders();\n    }\n\n    if (this.client.session.length) {\n      const lastKeyIndex = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[lastKeyIndex]);\n      this.onSessionUpdate();\n    }\n  }\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    await this.createClient();\n    this.checkStorage();\n    this.registerEventListeners();\n  }\n\n  private async createClient() {\n    this.client =\n      this.providerOpts.client ||\n      (await SignClient.init({\n        logger: this.providerOpts.logger || LOGGER,\n        relayUrl: this.providerOpts.relayUrl || RELAY_URL,\n        projectId: this.providerOpts.projectId,\n        metadata: this.providerOpts.metadata, // fetch metadata automatically if not provided?\n        storageOptions: this.providerOpts.storageOptions,\n        name: this.providerOpts.name,\n      }));\n\n    this.logger.trace(`SignClient Initialized`);\n  }\n\n  private createProviders(): void {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n\n    Object.keys(this.namespaces).forEach((namespace) => {\n      switch (namespace) {\n        case \"eip155\":\n          this.rpcProviders[namespace] = new Eip155Provider({\n            client: this.client,\n            namespace: this.namespaces[namespace],\n            events: this.events,\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[namespace] = new SolanaProvider({\n            client: this.client,\n            namespace: this.namespaces[namespace],\n            events: this.events,\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[namespace] = new CosmosProvider({\n            client: this.client,\n            namespace: this.namespaces[namespace],\n            events: this.events,\n          });\n          break;\n        case \"polkadot\":\n          //TODO:\n          break;\n        case \"cip34\":\n          this.rpcProviders[namespace] = new CardanoProvider({\n            client: this.client,\n            namespace: this.namespaces[namespace],\n            events: this.events,\n          });\n          break;\n      }\n    });\n  }\n\n  private registerEventListeners(): void {\n    if (typeof this.client === \"undefined\") {\n      throw new Error(\"Sign Client is not initialized\");\n    }\n\n    this.client.on(\"session_ping\", (args) => {\n      this.events.emit(\"session_ping\", args);\n    });\n\n    this.client.on(\"session_event\", (args) => {\n      const { params } = args;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        this.events.emit(\"accountsChanged\", event.data);\n      } else if (event.name === \"chainChanged\") {\n        this.onChainChanged(event.data, params.chainId);\n      } else {\n        this.events.emit(event.name, event.data);\n      }\n\n      this.events.emit(\"session_event\", args);\n    });\n\n    this.client.on(\"session_update\", ({ topic, params }) => {\n      const { namespaces } = params;\n      const _session = this.client?.session.get(topic);\n      this.session = { ..._session, namespaces } as SessionTypes.Struct;\n      this.onSessionUpdate();\n      this.events.emit(\"session_update\", { topic, params });\n    });\n\n    this.client.on(\"session_delete\", async (payload) => {\n      await this.cleanup();\n      this.events.emit(\"session_delete\", payload);\n    });\n  }\n\n  private getProvider(namespace: string): IProvider {\n    if (!this.rpcProviders[namespace]) {\n      throw new Error(`Provider not found: ${namespace}`);\n    }\n    return this.rpcProviders[namespace];\n  }\n\n  private onSessionUpdate(): void {\n    Object.keys(this.rpcProviders).forEach((namespace: string) => {\n      this.getProvider(namespace).updateNamespace(\n        this.session?.namespaces[namespace] as SessionTypes.BaseNamespace,\n      );\n    });\n  }\n\n  private setNamespaces(namespaces: NamespaceConfig): void {\n    if (!namespaces || !Object.keys(namespaces).length) {\n      throw new Error(\"Namespaces must be not empty\");\n    }\n    this.client.core.storage.setItem(`${STORAGE}/namespaces`, namespaces);\n    this.namespaces = namespaces;\n  }\n\n  private validateChain(chain?: string): [string, string] {\n    const [namespace, chainId] = chain?.split(\":\") || [\"\", \"\"];\n\n    // validate namespace\n    if (namespace) {\n      if (!Object.keys(this.namespaces).includes(namespace)) {\n        throw new Error(\n          `Namespace '${namespace}' is not configured. Please call connect() first with namespace config.`,\n        );\n      }\n    }\n\n    return !namespace || !chainId ? getChainFromNamespaces(this.namespaces) : [namespace, chainId];\n  }\n\n  private async requestAccounts(): Promise<string[]> {\n    const [namespace] = this.validateChain();\n    return await this.getProvider(namespace).requestAccounts();\n  }\n\n  private onChainChanged(newChain: string, caip2Chain: string): void {\n    const [namespace, chainId] = this.validateChain(caip2Chain);\n    this.getProvider(namespace).setDefaultChain(chainId);\n    this.events.emit(\"chainChanged\", newChain);\n  }\n\n  private onConnect() {\n    this.events.emit(\"connect\", { session: this.session });\n  }\n\n  private async cleanup() {\n    this.session = undefined;\n    await this.cleanupPendingPairings({ deletePairings: true });\n  }\n}\nexport default UniversalProvider;\n","import { UniversalProvider as Provider } from \"./UniversalProvider\";\nexport * from \"./types\";\nexport const UniversalProvider = Provider;\nexport default Provider;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}